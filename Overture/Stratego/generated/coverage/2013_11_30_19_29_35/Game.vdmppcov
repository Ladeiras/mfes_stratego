class Game
	types
		public Position:: column : nat row : nat
	instance variables
		public player1 : Player;
		public player2 : Player;
		public turn : seq of char;
		public board : map Position to Piece := {|->};
		
		--       0   1   2
		--     +---+---+---
		--   0 |   |   |   
		--     +---+---+---
		--   1 |   |   |   
		
	--Number pieces in the board
	--inv card dom board = 100;
	
	--Position columns and rows
	--inv forall p in set dom board & (p.column <=9 and p.row <=9);
	
	--Turn must be either "red" or "blue"
	inv turn = "red" or turn = "blue";
	
	operations
		public Game : () ==> Game
			Game() ==
			(
				--Players
				player1 := new Player(new Color("red"));
				player2 := new Player(new Color("blue"));
				turn := "red";
				
				--Fill the empty and water positions
				initialize();
				
				return self
			);
			
		--Fill the empty and water positions
		public initialize : () ==> ()
			initialize() ==
			(
				dcl c : nat := 0;
				dcl r : nat := 0;
				
				--Add empty pieces
				while(r < 10) do
				(
					while(c < 10) do
					(
						addPiece(mk_Position(c,r), new Piece(new Rank("null"), new Color("null")));
						
						c:= c+1;
					);
					
					c := 0;
					r := r+1;
				);
				
				--Add water
				addPiece(mk_Position(2,4), new Piece(new Rank("water"), new Color("null")));
				addPiece(mk_Position(2,5), new Piece(new Rank("water"), new Color("null")));
				addPiece(mk_Position(3,4), new Piece(new Rank("water"), new Color("null")));
				addPiece(mk_Position(3,5), new Piece(new Rank("water"), new Color("null")));
				
				addPiece(mk_Position(6,4), new Piece(new Rank("water"), new Color("null")));
				addPiece(mk_Position(6,5), new Piece(new Rank("water"), new Color("null")));
				addPiece(mk_Position(7,4), new Piece(new Rank("water"), new Color("null")));
				addPiece(mk_Position(7,5), new Piece(new Rank("water"), new Color("null")));
			);
			
		--Add new Piece
		public addPiece : Position*Piece ==> ()
			addPiece(position, piece) ==
			(
				board := board ++
				{position |-> piece}
			);
			
		--Get piece in given position
		public getPiece : Position ==> Piece
			getPiece(pos) ==
			(
				return board(pos);
			);
		
		--Check if the piece in the position is the same color as the turn 
		public checkTurn : Position ==> bool
			checkTurn(p) ==
				(
					if board(p).color.name = turn
						then return true
					else return false
				);
			
		--Returns the color of the opponent
		public getOpponentColor : Position ==> seq of char
			getOpponentColor(p) ==
				(
					if board(p).color.name = "red"
						then return "blue"
					else return "red"
				);
				
		--Check if the "to" position color is valid
		public checkToPositionColor : Position*Position ==> bool
			checkToPositionColor(p1,p2) ==
				(
					if board(p2).color.name = getOpponentColor(p1) or
						 board(p2).color.name = "null"
						then return true
					else return false
				)
				pre checkTurn(p1);
				
		--Check if the middle pieces are empty and not water
		public checkMiddlePieces : Position*Position ==> nat
			checkMiddlePieces(p_from, p_to) ==
			(
				dcl pSet : set of Position;
				
				if p_to.column > p_from.column and
					 p_to.row = p_from.row -- right
					 then pSet := {p | p in set dom board & 
					(p.column < p_to.column and p.column > p_from.column and p.row = p_from.row)}
				elseif p_to.column < p_from.column and
							 p_to.row = p_from.row -- left
					 then pSet := {p | p in set dom board & 
					(p.column > p_to.column and p.column < p_from.column and p.row = p_from.row)}
				elseif p_to.column = p_from.column and
							 p_to.row < p_from.row -- up
					 then pSet := {p | p in set dom board & 
					(p.row > p_to.row and p.row < p_from.row and p.column = p_from.column)}
				elseif p_to.column = p_from.column and
							 p_to.row > p_from.row -- down
					 then pSet := {p | p in set dom board & 
					(p.row < p_to.row and p.row > p_from.row and p.column = p_from.column)}
				else return false;
							
				--return forall p in set pSet & board(p).rank.name = "null";
				return card pSet;
				
			)
			pre checkTurn(p_from);
			
		--Validate move
		public validMove : nat*nat*nat*nat ==> bool
			validMove(fc,fr,tc,tr) ==
			(
				dcl p1 : Position := mk_Position(fc,fr);
				dcl p2 : Position := mk_Position(tc,tr);
				dcl positions : set of Position := {p1,p2};
				return positions subset dom board and
					checkToPositionColor(p1,p2);-- and
					--checkMiddlePieces(p1,p2);
			)
			pre fc >= 0 and fc <= 9 and fr >= 0 and fr <= 9 and
					tc >= 0 and tc <= 9 and tr >= 0 and tr <= 9;
					
			--Move Piece
			public move : nat*nat*nat*nat ==> bool
				move(fc,fr,tc,tr) ==
				(
					dcl p1 : Position := mk_Position(fc,fr);
					dcl p2 : Position := mk_Position(tc,tr);
					board := board ++ 
						{p2 |-> board(p1)};
					return true;
				)
				pre validMove(fc,fr,tc,tr);
			
		
end Game